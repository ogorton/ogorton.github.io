<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Oliver Gorton</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="style.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="../index.html">Home</a><br />
<a href="../blog.html">Notes</a></p>
<h1 id="spooling-n-dimensional-arrays">Spooling n-dimensional
arrays</h1>
<p>To spool an n-dimensional array into a 1-d array, we need to map an
arbitrary number of indices into a single index <span
class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[\begin{align}
    \mathrm{spool}(y) \leftarrow \mathrm{array}[i,j,k,l,m,n,o,p,...],
\end{align}\]</span></p>
<p>To create a one-to-one correspondence, we have to assign an order to
the <span class="math inline">\(n\)</span> indices:</p>
<p><span class="math display">\[\begin{align}
    x_n &gt; x_{n-1} &gt; ... &gt; x_1.
\end{align}\]</span></p>
<p>Let’s further define that each index <span
class="math inline">\(x\)</span> runs from <span
class="math inline">\(x^{min}\)</span> to <span
class="math inline">\(x^{max}\)</span>. At which point we can use the
following mapping:</p>
<p><span class="math display">\[\begin{align}
    y = x_n + \sum_{i&lt;n} (x_i -
x_i^{min})\prod_{j&gt;i}(x_j^{max}-x_j^{min}+1).
\end{align}\]</span></p>
<p>This mapping is only unique up to a choice of ordering.</p>
<h2 id="d-example">2-d example</h2>
<p>For example, in a two dimensional array <span
class="math inline">\(\mathrm{array}[x_2, x_1]\)</span> where <span
class="math inline">\(x_1 = 1, ..., m\)</span>, and <span
class="math inline">\(x_2 = 0, ..., n-1\)</span>:</p>
<p><span class="math display">\[
\begin{align}
    y &amp;= x_2 + (x_1 - 1)(n-1-0+1)\\
    &amp;=x_2 + (x_1-1)n.
\end{align}
\]</span></p>
<p>We could have also exchanged the ordering of the indices and
used:</p>
<p><span class="math display">\[\begin{align}
    y &amp;= x_1 + (x_2-0)(m-1+1)\\
    &amp;=x_1 + x_2m.
\end{align}\]</span></p>
<h2 id="d-example-1">3-d example</h2>
<p>Suppose a three dimensional array <span
class="math inline">\(\mathrm{array}[x_1, x_2, x_3]\)</span> where <span
class="math inline">\(x_1 = 1, ..., r\)</span>, <span
class="math inline">\(x_2 = 0, ..., s\)</span>, and <span
class="math inline">\(x_3 = 1, ..., 2t\)</span>. We take the ordering
<span class="math inline">\(x_2 &gt; x_3 &gt; x_1\)</span>.</p>
<p><span class="math display">\[
\begin{align}
    y &amp;= x_2 + (x_3-1)(s-0+1) + (x_1-1)(2t-1+1)(s-0+1)\\
    &amp;= x_2 + (x_3-1)(s+1) + (x_1-1)2t(s+1).
\end{align}
\]</span></p>
<p>Again, changing the ordering will change the expression. This
ordering would be most efficient for a nested loop such as:</p>
<pre><code>do x1 = 1, r:
  do x3 = 1, 2t:
    do x2 = 0, s:
      y = x2 + (x3-1)(s+1) + (x1-1)*2*t*(s+1)
      access spool[y]</code></pre>
<p>This requires <span class="math inline">\(10(s+1)(2t)r\)</span>
integer operations to compute.</p>
<h2 id="sectors">Sectors</h2>
<p>The 3-d example in the previous section can be improved by
pre-computing parts of the index further up in the loop hierarchy.</p>
<p><span class="math display">\[\begin{align}
    y = x_n + \mathrm{sector}(x_{n-1},...,x_1),
\end{align}\]</span> where <span class="math display">\[\begin{align}
\text{sector}(x_{n-1},...,x_1) \equiv \sum_{ i &lt; n } (x_i -
x_i^{min})\mathrm{sectorsize}(i).
\end{align}\]</span></p>
<p>The sectorsize quantities do not depend on the loop variable <span
class="math inline">\(x_i\)</span>, and can therefore be pre-computed
beforehand:</p>
<p><span class="math display">\[\begin{align}
   \mathrm{sectorsize}(i) \equiv \prod_{j&gt;i}(x_j^{max}-x_j^{min}+1).
\end{align}\]</span></p>
<p>Or, recursively:</p>
<p><span class="math display">\[\begin{align}
    \mathrm{sectorsize}(i) = (x_i^{max}-x_i^{min}+1)
\mathrm{sectorsize}(i-1),
\end{align}\]</span></p>
<p>with sectorsize<span class="math inline">\((1)\)</span> = 1.</p>
<h2 id="improved-3-d-example">Improved 3-d example</h2>
<p>Taking the same 3-d example as before, we can improve the performance
by computing sectors in shallower loops and by pre-computing sector
sizes. Recall that: <span class="math display">\[\begin{align}
    y = x_2 + (x_3-1)(s+1) + (x_1-1)2t(s+1).
\end{align}\]</span> In this case:</p>
<pre><code>secsize1 = 1
secsize2 = (s+1) # * secsize1
secsize3 = (2*t) * secsize2

do x1 = 1, r:
  sector1 = (x1 - 1) * secsize3
  do x3 = 1, 2t:
    sector31 = (x3 - 1) * secsize2 + sector1
    do x2 = 0, s:
      y = x2 + sector31
      access spool[y]</code></pre>
<p>This requires <span class="math inline">\((2t)(s+1)r + 3(2t)r + 2r +
3\)</span> operations to compute. Assuming <span
class="math inline">\(2t\)</span>, <span
class="math inline">\(s\)</span>, and <span
class="math inline">\(r\)</span> are all similarly large, this is a
speedup of approximately <span
class="math inline">\(\frac{20str}{2str}=10\)</span>.</p>
<h1 id="un-spooling">Un-spooling</h1>
<p>Suppose we can a single do-loop which addresses a two-dimensional
array. How do we invert the map?</p>
<p>It depends on the access pattern. We could have a row-major access
pattern:</p>
<pre><code>1 4 7 
2 5 8
3 6 9</code></pre>
<p>In which case the mapping is <span
class="math display">\[\begin{align}
x_1 = (y - 1)/s_{x_1} + 1 \\
x_2 = \mod(y-1,s_{x_1}) +1
\end{align}\]</span></p>
<h2 id="upper-triangular">Upper triangular</h2>
<p>Suppose the desired access pattern is upper triangular:</p>
<pre><code>1 2 4 .
  3 5 .
    6 .
      .</code></pre>
<p>Then the mapping is: <span class="math display">\[\begin{align}
j &amp;= \text{ceiling}((\sqrt{8y+1}-1)/2)\\
i &amp;= y - i(i-1)/2
\end{align}\]</span> Here, <span class="math inline">\(i\)</span> is
fast and <span class="math inline">\(j\)</span> is slow. A nice aspect
of this layout is that the mapping does not depend on the size of the
array. However, it does rely on real-type arithmetic (but there’s a way
around that).</p>
<p>The compute cost of the <span class="math inline">\(j\)</span> index
is at least 5 FLOPS plus the cost of the ceiling function. The cost of
the <span class="math inline">\(i\)</span> index is 4 FLOPS. The former
is reduced to 4 FLOPS with: <span class="math display">\[\begin{align}
j &amp;= \text{ceiling}(\sqrt{2y+0.25}-0.5)\\
i &amp;= y - i(i-1)/2
\end{align}\]</span></p>
<p>To see why this seemingly arbitrary map works, notice from the label
pattern above that we are trying to map the first <span
class="math inline">\(N\)</span> integers onto the first <span
class="math inline">\(n\)</span> columns, where the <span
class="math inline">\(j\)</span>-th column has <span
class="math inline">\(j\)</span> consecutive labels. The maximum label
which <span class="math inline">\(n\)</span> rows can support is: <span
class="math display">\[\begin{align}
\sum_{j=1}^n j = \frac{n(n+1)}{2}.
\end{align}\]</span> The index <span class="math inline">\(y\)</span>
maps to the column with at least as many labels: <span
class="math display">\[\begin{align}
y \le \frac{j(j+1)}{2}.
\end{align}\]</span> The positive solution for <span
class="math inline">\(j\)</span> is: <span
class="math display">\[\begin{align}
j \le \frac{\sqrt{8y+1}-1}{2}.
\end{align}\]</span> Finally, by demanding that <span
class="math inline">\(j\)</span> be an integer, we find the first part
of the mapping: <span class="math display">\[\begin{align}
j = \text{ceiling}\left (\frac{\sqrt{8y+1}-1}{2}\right ).
\end{align}\]</span></p>
<p>Since the label <span class="math inline">\(y\)</span> increases by
one when increasing the row index <span
class="math inline">\(i\)</span>, all we need is to subtract the maximum
label from the previous column from <span
class="math inline">\(y\)</span> to get <span
class="math inline">\(i\)</span>. But this is just the sum of all
integers up to the previous column number <span
class="math inline">\(j&#39; = j-1\)</span>. A simple substitution gives
us the final result for the row <span class="math inline">\(i\)</span>:
<span class="math display">\[\begin{align}
i = y - \frac{j(j-1)}{2}.
\end{align}\]</span></p>
<p><em>A word of caution:</em> Since this map relies on real numbers, it
is susceptable to rouding errors. In particular, if <span
class="math inline">\(1/j\)</span> is small compared to the precision of
the real data type, then the ceiling function may go the wrong way!</p>
</body>
</html>
